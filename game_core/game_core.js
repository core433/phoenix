// Generated by CoffeeScript 1.9.0
var GameCore, GameCoreClient, PlayerClient, PlayerCore, libPlayer,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __hasProp = {}.hasOwnProperty;

if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
  libPlayer = require('./player');
  PlayerCore = libPlayer.PlayerCore;
  PlayerClient = libPlayer.PlayerClient;
}

GameCore = (function() {
  function GameCore(_at_server_game_instance, _at_client) {
    this.server_game_instance = _at_server_game_instance;
    this.client = _at_client != null ? _at_client : false;
    if (this.client) {
      this.players = {
        myself: new window.PlayerClient(this),
        others: []
      };
    } else {
      this.players = {
        myself: new PlayerCore(this, this.server_game_instance.player_host),
        others: []
      };
    }
    this.pdt = 0.015;
    this.pcur = 0.0001;
    this.plast = new Date().getTime();
    this.paccum = this.pcur;
    if (this.client) {
      this.udt = 0.016;
    } else {
      this.udt = 0.045;
    }
    this.ucur = 0.0001;
    this.ulast = new Date().getTime();
    this.uaccum = this.ucur;
    this.local_time = 0.016;
    this.dt = new Date().getTime();
    this.dte = new Date().getTime();
    this.create_physics_loop();
    this.create_update_loop();
    this.create_timer();
    if (!this.client) {
      this.server_time = 0;
      this.laststate = {};
    }
  }

  GameCore.prototype.add_player = function(userid, server_player_instance) {
    var new_player;
    if (server_player_instance == null) {
      server_player_instance = null;
    }
    'Adds a non-host player to the game.  Note that the host\nwas already added as the first player when they started the game.';
    if (this.client) {
      new_player = new window.PlayerClient(this);
      new_player.publicid = userid;
    } else {
      new_player = new PlayerCore(this, server_player_instance);
    }
    return this.players.others.push(new_player);
  };

  GameCore.prototype.reset_player_positions = function() {
    'When the game starts will want to move all players to their spawn positions.\nSince the player\'s publicid is available on both server and client, we\nsort using publicid to determine the order of spawn position for players.';
    var all_pids, pid, pid_pos, player, pos, posi, spawn_positions, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
    spawn_positions = [[200, 200], [600, 200], [200, 600], [600, 600]];
    all_pids = [];
    all_pids.push(this.players.myself.publicid);
    _ref = this.players.others;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      player = _ref[_i];
      all_pids.push(player.publicid);
    }
    all_pids.sort();
    pid_pos = {};
    posi = 0;
    for (_j = 0, _len1 = all_pids.length; _j < _len1; _j++) {
      pid = all_pids[_j];
      pid_pos[pid] = spawn_positions[posi];
      posi++;
    }
    pid = this.players.myself.publicid;
    pos = pid_pos[pid];
    this.players.myself.setPos(pos[0], pos[1]);
    _ref1 = this.players.others;
    _results = [];
    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
      player = _ref1[_k];
      pid = player.publicid;
      pos = pid_pos[pid];
      _results.push(player.setPos(pos[0], pos[1]));
    }
    return _results;
  };

  GameCore.prototype.create_physics_loop = function() {
    var self;
    console.log('CREATE PHYSICS LOOP');
    self = this;
    return setInterval(function() {
      return self.update_physics();
    }, this.pdt * 1000);
  };

  GameCore.prototype.update_physics = function() {
    var curTime, _results;
    curTime = new Date().getTime();
    this.pcur = (curTime - this.plast) / 1000.0;
    this.plast = curTime;
    this.paccum += this.pcur;
    _results = [];
    while (this.paccum >= this.pdt) {
      this.paccum -= this.pdt;
      _results.push(this.do_update_physics());
    }
    return _results;
  };

  GameCore.prototype.do_update_physics = function() {
    if (this.client) {
      return this.client_update_physics();
    } else {
      return this.server_update_physics();
    }
  };

  GameCore.prototype.server_update_physics = function() {
    var new_dir, player, _i, _j, _len, _len1, _ref, _ref1, _results;
    this.players.myself.old_state.pos = PlayerCore.copyPos(this.players.myself.pos);
    new_dir = this.process_input(this.players.myself);
    this.players.myself.pos = PlayerCore.addPos(this.players.myself.old_state.pos, new_dir);
    _ref = this.players.others;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      player = _ref[_i];
      player.old_state.pos = PlayerCore.copyPos(player.pos);
      new_dir = this.process_input(player);
      player.pos = PlayerCore.addPos(player.old_state.pos, new_dir);
    }
    this.players.myself.inputs = [];
    _ref1 = this.players.others;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      player = _ref1[_j];
      _results.push(player.inputs = []);
    }
    return _results;
  };

  GameCore.prototype.create_update_loop = function() {
    'On the server, creates the 45 ms broadcast loop to update all the players.\nOn the client, creates the 16 ms refresh loop to redraw the world state.';
    var self;
    console.log('CREATE UPDATE LOOP');
    self = this;
    return setInterval(function() {
      return self.update();
    }, this.udt * 1000);
  };

  GameCore.prototype.update = function() {
    var curTime, _results;
    curTime = new Date().getTime();
    this.ucur = (curTime - this.ulast) / 1000.0;
    this.ulast = curTime;
    this.uaccum += this.ucur;
    _results = [];
    while (this.uaccum >= this.udt) {
      this.uaccum -= this.udt;
      if (this.client) {
        _results.push(this.do_client_update());
      } else {
        _results.push(this.do_server_update());
      }
    }
    return _results;
  };

  GameCore.prototype.do_server_update = function() {
    'Broadcast loop, send last state to all players';
    var pid, player, player_states, _i, _j, _len, _len1, _ref, _ref1, _results;
    this.server_time = this.local_time;
    player_states = {};
    pid = this.players.myself.publicid;
    player_states[pid] = {
      pos: this.players.myself.pos,
      last_input_seq: this.players.myself.last_input_seq
    };
    _ref = this.players.others;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      player = _ref[_i];
      pid = player.publicid;
      player_states[pid] = {
        pos: player.pos,
        last_input_seq: player.last_input_seq
      };
    }
    this.laststate = {
      players: player_states,
      t: this.server_time
    };
    if (this.players.myself.server_player_instance) {
      this.players.myself.server_player_instance.emit('onserverupdate', this.laststate);
    }
    _ref1 = this.players.others;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      player = _ref1[_j];
      if (player.server_player_instance) {
        _results.push(player.server_player_instance.emit('onserverupdate', this.laststate));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  GameCore.prototype.process_input = function(player) {
    'For a player, process any stored inputs in their player.inputs queue,\nand return the vector of updated position based on inputs';
    var c, i, input, j, key, n_inputs, resulting_vector, x_dir, _i, _j;
    x_dir = 0;
    n_inputs = player.inputs.length;
    if (n_inputs > 0) {
      for (j = _i = 0; 0 <= n_inputs ? _i < n_inputs : _i > n_inputs; j = 0 <= n_inputs ? ++_i : --_i) {
        if (Number(player.inputs[j].seq) <= Number(player.last_input_seq)) {
          continue;
        }
        input = player.inputs[j].inputs;
        c = input.length;
        for (i = _j = 0; 0 <= c ? _j < c : _j > c; i = 0 <= c ? ++_j : --_j) {
          key = input[i];
          if (key === 'l') {
            x_dir -= 1;
          }
          if (key === 'r') {
            x_dir += 1;
          }
        }
      }
    }
    resulting_vector = {
      x: x_dir,
      y: 0
    };
    if (player.inputs.length) {
      player.last_input_time = player.inputs[n_inputs - 1].time;
      player.last_input_seq = player.inputs[n_inputs - 1].seq;
    }
    return resulting_vector;
  };

  GameCore.prototype.handle_server_input = function(client, input, input_time, input_seq) {
    'After receiving input from the client, store the inputs in the player\'s\ninputs queue for later processing.';
    var player, server_input, _i, _len, _ref, _results;
    if (client.userid === this.players.myself.server_player_instance.userid) {
      server_input = {
        inputs: input,
        time: input_time,
        seq: input_seq
      };
      return this.players.myself.inputs.push(server_input);
    } else {
      _ref = this.players.others;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (client.userid === player.server_player_instance.userid) {
          server_input = {
            inputs: input,
            time: input_time,
            seq: input_seq
          };
          _results.push(player.inputs.push(server_input));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  GameCore.prototype.create_timer = function() {
    'Creates a timer which refreshes every 4ms for purposes of updating\n@local_time relatively accurately.';
    var self;
    self = this;
    return setInterval(function() {
      return self.update_timer();
    }, 4);
  };

  GameCore.prototype.update_timer = function() {
    this.dt = new Date().getTime() - this.dte;
    this.dte = new Date().getTime();
    return this.local_time += this.dt / 1000.0;
  };

  GameCore.prototype.server_load_world = function() {
    'Since the server does not run a game engine, it needs to manually load\nthe terrain image';
    var worldImg;
    worldImg = new Image();
    worldImg.src = 'assets/images/test_load.png';
    return worldImg.onLoad = this.server_world_loaded();
  };

  GameCore.prototype.server_world_loaded = function() {
    return console.log('XXX world is loaded');
  };

  return GameCore;

})();

GameCoreClient = (function(_super) {
  __extends(GameCoreClient, _super);

  function GameCoreClient() {
    GameCoreClient.__super__.constructor.call(this, null, true);
    this.networkHelper = new window.ClientNetwork(this);
    this.input_seq = 0;
    this.client_smooth = 25;
    this.net_offset = 100;
    this.buffer_size = 2;
    this.target_time = 0.01;
    this.oldest_tick = 0.01;
    this.client_time = 0.01;
    this.server_time = 0.01;
    this.phaserGame = null;
    this.phaserLoaded = false;
    this.keyboard = new THREEx.KeyboardState();
    this.server_updates = [];
  }

  GameCoreClient.prototype.client_update_physics = function() {
    var copy_pos, cur_pos, nd;
    cur_pos = this.players.myself.cur_state.pos;
    copy_pos = window.PlayerCore.copyPos(cur_pos);
    this.players.myself.old_state.pos = copy_pos;
    nd = this.process_input(this.players.myself);
    this.players.myself.cur_state.pos = window.PlayerCore.addPos(copy_pos, nd);
    return this.players.myself.state_time = this.local_time;
  };

  GameCoreClient.prototype.do_client_update = function() {
    this.handle_client_input();
    this.client_process_net_updates();
    return this.client_update_local_position();
  };

  GameCoreClient.prototype.handle_client_input = function() {
    'captures input from active player via keyboard, stores them in active\nplayer\'s input queue and posts them to server.';
    var input, server_packet, x_dir, xdir;
    x_dir = 0;
    input = [];
    this.client_has_input = false;
    if (this.keyboard.pressed('left')) {
      xdir = -1;
      input.push('l');
    }
    if (this.keyboard.pressed('right')) {
      xdir = 1;
      input.push('r');
    }
    if (input.length) {
      this.input_seq += 1;
      this.players.myself.inputs.push({
        inputs: input,
        time: this.local_time.toFixed(3),
        seq: this.input_seq
      });
      server_packet = 'i.';
      server_packet += input.join('-') + '.';
      server_packet += this.local_time.toFixed(3).replace('.', '-') + '.';
      server_packet += this.input_seq;
      return this.networkHelper.send(server_packet);
    }
  };

  GameCoreClient.prototype.client_process_net_updates = function() {
    'This handles positions of other players, as told by the server';
    var count, current_time, difference, i, latest_server_data, max_difference, next_point, other_past_pos, other_server_pos, other_target_pos, player, player_pos, point, pre_smooth_pos, previous, target, time_point, _i, _j, _len, _ref, _results;
    if (!this.server_updates.length) {
      return;
    }
    current_time = this.client_time;
    count = this.server_updates.length - 1;
    target = null;
    previous = null;
    for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
      point = this.server_updates[i];
      next_point = this.server_updates[i + 1];
      if (current_time > point.t && current_time < next_point.t) {
        target = next_point;
        previous = point;
        break;
      }
    }
    if (target === null) {
      target = this.server_updates[0];
      previous = this.server_updates[0];
    }
    if (target && previous) {
      this.target_time = target.t;
      difference = this.target_time - current_time;
      max_difference = (target.t - previous.t).toFixed(3);
      time_point = (difference / max_difference).toFixed(3);
      if (isNaN(time_point) || time_point === -Infinity || time_point === Infinity) {
        time_point = 0;
      }
      latest_server_data = this.server_updates[this.server_updates.length - 1];
      _ref = this.players.others;
      _results = [];
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        player = _ref[_j];
        other_server_pos = latest_server_data.players[player.publicid].pos;
        other_target_pos = target.players[player.publicid].pos;
        other_past_pos = previous.players[player.publicid].pos;
        pre_smooth_pos = window.PlayerCore.lerpPos(other_past_pos, other_target_pos, time_point);
        player_pos = window.PlayerCore.lerpPos(player.pos, pre_smooth_pos, this.pdt * this.client_smooth);
        _results.push(player.setPos(player_pos.x, player_pos.y));
      }
      return _results;
    }
  };

  GameCoreClient.prototype.client_update_local_position = function() {
    'Does client prediction';
    var cur_state, old_state, t;
    t = (this.local_time - this.players.myself.state_time) / this.pdt;
    old_state = this.players.myself.old_state.pos;
    cur_state = this.players.myself.cur_state.pos;
    this.players.myself.pos = cur_state;
    return this.players.myself.setPos(cur_state.x, cur_state.y);
  };

  return GameCoreClient;

})(GameCore);

if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
  exports.GameCore = GameCore;
  exports.GameCoreClient = GameCoreClient;
} else {
  window.GameCore = GameCore;
  window.GameCoreClient = GameCoreClient;
}
