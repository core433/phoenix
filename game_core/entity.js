// Generated by CoffeeScript 1.9.0
'Entity object\n\n  Represents the physical (not graphical) object in the scene.\n  Simulates using simple Euler integration for now.\n  Has a box param which acts as its collision body (width & height)\n\n';
var EntityCore;

EntityCore = (function() {
  function EntityCore(_at_shost) {
    this.shost = _at_shost;
    this.pos = {
      x: 0,
      y: 0
    };
    this.vel = {
      x: 0,
      y: 0
    };
    this.force = {
      x: 0,
      y: 0
    };
    this.mass = 1;
    this.box = {
      x: 0,
      y: 0
    };
    this.offset = {
      x: 0,
      y: 0
    };
  }

  EntityCore.prototype.initialize = function(x, y, width, height, offX, offY) {
    this.pos.x = x;
    this.pos.y = y;
    this.box.x = width;
    this.box.y = height;
    this.offset.x = offX;
    return this.offset.y = offY;
  };

  EntityCore.prototype.setForce = function(fx, fy) {
    this.force.x = fx;
    return this.force.y = fy;
  };

  EntityCore.prototype.leftBound = function() {
    return this.pos.x + this.offset.x - Math.floor(this.box.x / 2);
  };

  EntityCore.prototype.rightBound = function() {
    return this.pos.x + this.offset.x + Math.floor(this.box.x / 2);
  };

  EntityCore.prototype.topBound = function() {
    return this.pos.y + this.offset.y - Math.floor(this.box.y / 2);
  };

  EntityCore.prototype.botBound = function() {
    return this.pos.y + this.offset.y + Math.floor(this.box.y / 2);
  };

  EntityCore.prototype.setPos = function(x, y) {
    this.pos.x = x;
    return this.pos.y = y;
  };

  EntityCore.prototype.getPos = function() {
    return {
      x: this.pos.x,
      y: this.pos.y
    };
  };

  EntityCore.prototype.update = function(dt) {
    'Physics is currently simple Euler integration, which isn\'t completely\naccurate, but should work fine for simple game physics\nReturns whether position changed';
    var accel, old_pos;
    old_pos = {
      x: this.pos.x,
      y: this.pos.y
    };
    this.pos = {
      x: this.pos.x + this.vel.x * dt,
      y: this.pos.y + this.vel.y * dt
    };
    accel = {
      x: this.force.x / mass,
      y: this.force.y / mass
    };
    this.vel = {
      x: this.vel.x + accel.x * dt,
      y: this.vel.y + accel.y * dt
    };
    return old_pos.x !== this.pos.x && old_pos.y !== this.pos.y;
  };

  EntityCore.prototype.collidesWithEntity = function(entity) {
    'Don\'t need to check every point of the rectangles, just need to check\nif the bottoms are outside of each others\' reach';
    var botRight1, botRight2, topLeft1, topLeft2;
    topLeft1 = [this.leftBound(), this.topBound()];
    topLeft2 = [entity.leftBound(), entity.topBound()];
    botRight1 = [this.rightBound(), this.botBound()];
    botRight2 = [entity.rightBound(), entity.botBound()];
    if (topLeft1[0] > botRight2[0] || topLeft2[0] > botRight1[0]) {
      return false;
    }
    if (topLeft1[1] > botRight2[1] || topLeft2[1] > botRight1[1]) {
      return false;
    }
    return true;
  };

  return EntityCore;

})();

if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
  exports.EntityCore = EntityCore;
} else {
  window.EntityCore = EntityCore;
}
